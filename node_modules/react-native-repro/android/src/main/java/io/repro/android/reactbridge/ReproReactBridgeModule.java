
package io.repro.android.reactbridge;

import android.util.Log;


import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableNativeArray;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.Arguments;

import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.json.JSONObject;

import io.repro.android.Repro;
import io.repro.android.tracking.AddPaymentInfoProperties;
import io.repro.android.tracking.AddToCartProperties;
import io.repro.android.tracking.AddToWishlistProperties;
import io.repro.android.tracking.CompleteRegistrationProperties;
import io.repro.android.tracking.InitiateCheckoutProperties;
import io.repro.android.tracking.LeadProperties;
import io.repro.android.tracking.PurchaseProperties;
import io.repro.android.tracking.SearchProperties;
import io.repro.android.tracking.ShareProperties;
import io.repro.android.tracking.ViewContentProperties;
import io.repro.android.user.UserProfileGender;
import io.repro.android.newsfeed.NewsFeedEntry;


public class ReproReactBridgeModule extends ReactContextBaseJavaModule {

    public static final int GENDER_OTHER  = 0;
    public static final int GENDER_MALE   = 1;
    public static final int GENDER_FEMALE = 2;

    private final ReactApplicationContext reactContext;

    public ReproReactBridgeModule(ReactApplicationContext reactContext) {
        super(reactContext);
        this.reactContext = reactContext;
    }

    @Override
    public String getName() {
        return "Repro";
    }

    @Override
    public Map<String, Object> getConstants() {
        final Map<String, Object> constants = new HashMap<>();

        constants.put("GENDER_OTHER",  GENDER_OTHER);
        constants.put("GENDER_MALE",   GENDER_MALE);
        constants.put("GENDER_FEMALE", GENDER_FEMALE);

        constants.put("LOGLEVEL_DEBUG", Log.DEBUG);
        constants.put("LOGLEVEL_INFO",  Log.INFO);
        constants.put("LOGLEVEL_WARN",  Log.WARN);
        constants.put("LOGLEVEL_ERROR", Log.ERROR);

        return constants;
    }

    @ReactMethod
    public void optIn(boolean endUserOptedIn) {
        Repro.optIn(endUserOptedIn);
    }

    @ReactMethod
    public void setUserID(final String userId) {
        Repro.setUserID(userId);
    }

    @ReactMethod
    public void getUserID(Callback callback) {
        callback.invoke(null, Repro.getUserID());
    }

    @ReactMethod
    public void setSilverEggCookie(final String cookie) {
        Repro.setSilverEggCookie(cookie);
    }

    @ReactMethod
    public void setSilverEggProdKey(final String prodKey) {
        Repro.setSilverEggProdKey(prodKey);
    }

    @ReactMethod
    public void setLogLevel(final int logLevel) {
        Repro.setLogLevel(logLevel);
    }

    @ReactMethod
    public void setStringUserProfile(final String key, final String value) {
        Repro.setStringUserProfile(key, value);
    }

    @ReactMethod
    public void setIntUserProfile(final String key, final int value) {
        Repro.setIntUserProfile(key, value);
    }

    @ReactMethod
    public void setDoubleUserProfile(final String key, final double value) {
        Repro.setDoubleUserProfile(key, value);
    }

    @ReactMethod
    public void setDateUserProfile(final String key, final String value) {
        try{
            String isoTime = value.replace("Z", "+00:00");
            Date date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").parse(isoTime);
            Repro.setDateUserProfile(key, date);
        }
        catch(Exception e) {
            Log.e("Repro", "Wrong formatted date String: " + value);
        }
    }

    @ReactMethod
    public void setUserEmailAddress(final String mailAddr) {
        Repro.setUserEmailAddress(mailAddr);
    }

    @ReactMethod
    public void setUserGender(final int gender) {
        if (BuildConfig.DEBUG) {
            Repro.setUserGender(UserProfileGender.values()[gender]);
            return;
        }

        try {
            Repro.setUserGender(UserProfileGender.values()[gender]);
        }
        catch(ArrayIndexOutOfBoundsException exception) {
            Log.e("Repro", "Wrong gender selected. Allowed values are GENDER_MALE, GENDER_FEMALE and GENDER_OTHER.");
        }
    }

    @ReactMethod
    public void getDeviceID(Callback callback) {
        callback.invoke(null, Repro.getDeviceID());
    }

    @ReactMethod
    public void disableInAppMessagesOnForegroundTransition() {
        Repro.disableInAppMessagesOnForegroundTransition();
    }

    @ReactMethod
    public void enableInAppMessagesOnForegroundTransition() {
        Repro.enableInAppMessagesOnForegroundTransition(this.getCurrentActivity());
    }

    @ReactMethod
    public void setPushRegistrationID(final String pushRegId) {
        Repro.setPushRegistrationID(pushRegId);
    }

    @ReactMethod
    public void enablePushNotification() {
        Repro.enablePushNotification();
    }

    @ReactMethod
    public void track(final String name, final ReadableMap properties) {
        Repro.track(name, properties.toHashMap());
    }

    @ReactMethod
    public void trackViewContent(final String contentId, final ReadableMap props) {
        ViewContentProperties properties = new ViewContentProperties();

        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackViewContent(contentId, properties);
    }

    @ReactMethod
    public void trackSearch(final ReadableMap props) {
        SearchProperties properties = new SearchProperties();

        if (props.hasKey("content_id"))            { properties.setContentId(        props.getString("content_id")); }
        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("search_string"))         { properties.setSearchString(     props.getString("search_string")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackSearch(properties);
    }

    @ReactMethod
    public void trackAddToWishlist(final ReadableMap props) {
        AddToWishlistProperties properties = new AddToWishlistProperties();

        if (props.hasKey("content_id"))            { properties.setContentId(        props.getString("content_id")); }
        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackAddToWishlist(properties);
    }

    @ReactMethod
    public void trackAddToCart(final String contentId, final ReadableMap props) {
        AddToCartProperties properties = new AddToCartProperties();

        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackAddToCart(contentId, properties);
    }

    @ReactMethod
    public void trackInitiateCheckout(final ReadableMap props) {
        InitiateCheckoutProperties properties = new InitiateCheckoutProperties();

        if (props.hasKey("content_id"))            { properties.setContentId(        props.getString("content_id")); }
        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("num_items"))             { properties.setNumItems(         props.getInt("num_items")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackInitiateCheckout(properties);
    }

    @ReactMethod
    public void trackAddPaymentInfo(final ReadableMap props) {
        AddPaymentInfoProperties properties = new AddPaymentInfoProperties();

        if (props.hasKey("content_id"))            { properties.setContentId(        props.getString("content_id")); }
        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackAddPaymentInfo(properties);
    }

    @ReactMethod
    public void trackPurchase(final String contentId, final double value, final String currency, final ReadableMap props) {
        PurchaseProperties properties = new PurchaseProperties();

        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("num_items"))             { properties.setNumItems(         props.getInt("num_items")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackPurchase(contentId, value, currency, properties);
    }

    @ReactMethod
    public void trackShare(final ReadableMap props) {
        ShareProperties properties = new ShareProperties();

        if (props.hasKey("content_id"))            { properties.setContentId(        props.getString("content_id")); }
        if (props.hasKey("service_name"))          { properties.setServiceName(      props.getString("service_name")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackShare(properties);
    }

    @ReactMethod
    public void trackCompleteRegistration(final ReadableMap props) {
        CompleteRegistrationProperties properties = new CompleteRegistrationProperties();

        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("status"))                { properties.setStatus(           props.getString("status")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackCompleteRegistration(properties);
    }

    @ReactMethod
    public void trackLead(final ReadableMap props) {
        LeadProperties properties = new LeadProperties();

        if (props.hasKey("value"))                 { properties.setValue(            props.getDouble("value")); }
        if (props.hasKey("content_name"))          { properties.setContentName(      props.getString("content_name")); }
        if (props.hasKey("currency"))              { properties.setCurrency(         props.getString("currency")); }
        if (props.hasKey("content_category"))      { properties.setContentCategory(  props.getString("content_category")); }
        if (props.hasKey("extras"))                { properties.setExtras(           props.getMap("extras").toHashMap()); }

        Repro.trackLead(properties);
    }

    @ReactMethod
    public void trackNotificationOpened(final String notificationId) {
        Repro.trackNotificationOpened(notificationId);
    }

    private WritableArray toWritableArray(List<NewsFeedEntry> entries) {
        WritableArray array = new WritableNativeArray();

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US);
        format.setTimeZone(TimeZone.getTimeZone("gmt"));

        for (NewsFeedEntry entry : entries) {
            WritableMap entryMap = Arguments.createMap();

            String linkUrl;
            if (entry.linkUrl == null) {
                linkUrl = "";
            } else {
                linkUrl = entry.linkUrl.toString().equals("null") ? "" : entry.linkUrl.toString();
            }

            String imageUrl;
            if (entry.imageUrl == null) {
                imageUrl = "";
            } else {
                imageUrl = entry.imageUrl.toString().equals("null") ? "" : entry.imageUrl.toString();
            }

            entryMap.putDouble("newsfeed_id", entry.id);
            entryMap.putString("device_id", entry.deviceID);
            entryMap.putString("title", entry.title);
            entryMap.putString("summary", entry.summary);
            entryMap.putString("body", entry.body);

            entryMap.putBoolean("shown", entry.shown);
            entryMap.putBoolean("read", entry.read);

            entryMap.putString("delivered_at", format.format(entry.deliveredAt));

            entryMap.putString("link_url", linkUrl);
            entryMap.putString("image_url", imageUrl);

            array.pushMap(entryMap);
        }

        return array;
    }

    @ReactMethod
    public void getNewsFeeds(final int limit, Callback callback) {
        try {
            callback.invoke(null, toWritableArray(Repro.getNewsFeeds(limit)));
        } catch (Exception e) {
            WritableMap entryMap = Arguments.createMap();
            entryMap.putString("message", e.getMessage());
            callback.invoke(entryMap, null);
        }
    }

    @ReactMethod
    public void getNewsFeedsFor(final int limit, final int offsetID, Callback callback) {
        try {
            callback.invoke(null, toWritableArray(Repro.getNewsFeeds(limit, offsetID)));
        } catch (Exception e) {
            WritableMap entryMap = Arguments.createMap();
            entryMap.putString("message", e.getMessage());
            callback.invoke(entryMap, null);
        }
    }

    @ReactMethod
    public void updateNewsFeeds(ReadableArray array, Callback callback) {
        List<NewsFeedEntry> entries = new ArrayList<>();

        for (int i = 0; i < array.size() ; i++) {
            Map<String, Object> map = array.getMap(i).toHashMap();
            JSONObject json = new JSONObject(map);
            entries.add(new NewsFeedEntry(json));
        }

        try {
            Repro.updateNewsFeeds(entries);
        } catch(Exception e) {
            WritableMap error = Arguments.createMap();
            error.putString("message", e.getMessage());
            callback.invoke(error);
        }
    }
}



