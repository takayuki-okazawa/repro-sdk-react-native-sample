package io.repro.android.reactbridge;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.ReadableMapKeySetIterator;
import com.facebook.react.bridge.ReadableType;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.Arguments;

import java.util.HashMap;
import java.util.Map;

import io.repro.android.Repro;
import io.repro.android.remoteconfig.RemoteConfigValue;
import io.repro.android.remoteconfig.RemoteConfigListener;

public class ReproRemoteConfigBridge extends ReactContextBaseJavaModule {

    public static final int REMOTE_CONFIG_SUCCESS         = 0;
    public static final int REMOTE_CONFIG_TIMEOUT_REACHED = 1;
    public static final int REMOTE_CONFIG_ALREADY_FETCHED = 2;

    public ReproRemoteConfigBridge(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    @Override
    public String getName() {
        return "RemoteConfig";
    }

    @Override
    public Map<String, Object> getConstants() {
        final Map<String, Object> constants = new HashMap<>();

        constants.put("REMOTE_CONFIG_SUCCESS",         REMOTE_CONFIG_SUCCESS);
        constants.put("REMOTE_CONFIG_TIMEOUT_REACHED", REMOTE_CONFIG_TIMEOUT_REACHED);
        constants.put("REMOTE_CONFIG_ALREADY_FETCHED", REMOTE_CONFIG_ALREADY_FETCHED);

        return constants;
    }

    private WritableMap toWritableMap(final Map<String, RemoteConfigValue> javaMap) {
        WritableMap map = Arguments.createMap();
        for (Map.Entry<String, RemoteConfigValue> entry : javaMap.entrySet()) {
            String value = entry.getValue().asString();
            if(value != null) {
                map.putString(entry.getKey(), value);
            }
        }

        return map;
    }

    private Map<String, Object> toMap(ReadableMap readableMap) {
        Map<String, Object> map = new HashMap<>();
        ReadableMapKeySetIterator iterator = readableMap.keySetIterator();

        while (iterator.hasNextKey()) {
          String key = iterator.nextKey();
          ReadableType type = readableMap.getType(key);

            switch (type) {
            case String:
                map.put(key, readableMap.getString(key));
                break;
            }
        }

        return map;
    }

    @ReactMethod
    public void fetch(final int timeout, final Callback callback) {
        Repro.getRemoteConfig().fetch((long)timeout, new RemoteConfigListener() {
            @Override
            public void onCompletion(RemoteConfigListener.FetchStatus status) {
                switch (status) {
                    case SUCCESS:
                        callback.invoke(0);
                        break;
                    case TIMEOUT_REACHED:
                        callback.invoke(1);
                        break;
                    case ALREADY_FETCHED:
                        callback.invoke(2);
                        break;
                }
            }
        });
    }

    @ReactMethod
    public void activateFetched() {
        Repro.getRemoteConfig().activateFetched();
    }

    // Default value settings
    @ReactMethod
    public void setDefaultsFromDictionary(final ReadableMap values) {
        Map<String, Object> map = toMap(values);
        Repro.getRemoteConfig().setDefaultsFromMap(map);
    }

    @ReactMethod
    public void setDefaultsFromJsonString(final String jsonStr) {
        Repro.getRemoteConfig().setDefaultsFromJsonString(jsonStr);
    }

    @ReactMethod
    public void getValue(final String key, final Callback callback) {
        String value = Repro.getRemoteConfig().get(key).asString();
        callback.invoke(value);
    }

    // Value accessor
    @ReactMethod
    public void getAllValues(final Callback callback) {
        Map<String, RemoteConfigValue> map = Repro.getRemoteConfig().getAllValues();
        callback.invoke(toWritableMap(map));
    }

    @ReactMethod
    public void getAllValuesWithPrefix(final String prefix, final Callback callback) {
        Map<String, RemoteConfigValue> map = Repro.getRemoteConfig().getAllValuesWithPrefix(prefix);
        callback.invoke(toWritableMap(map));
    }

    @ReactMethod
    public void getLocalDefaultValue(final String key, final Callback callback) {
        String value = Repro.getRemoteConfig().getLocalDefaultValue(key).asString();
        callback.invoke(value);
    }

    // Others
    @ReactMethod
    public void forceReset() {
        Repro.getRemoteConfig().forceReset();
    }
}
